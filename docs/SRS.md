# Software Requirements Specification (SRS)
# SQL 기반 Netflix 스타일 개인화 추천 시스템

버전: 1.0
작성일: 2025-12-04

---

## 1. 개요 (Introduction)

### 1.1 목적 (Purpose)

본 문서는 "SQL 기반 Netflix 스타일 개인화 추천 시스템"의 소프트웨어 요구사항을 정의한다.
해당 시스템은 공개 영화/시청 데이터셋을 활용하여 사용자에게 개인화된 콘텐츠(영화/TV 프로그램) 추천 기능을 제공하는 것을 목표로 한다.

이 SRS는 다음을 위해 작성된다:

- 개발자 본인의 구현 범위와 우선순위 명확화
- 포트폴리오 문서화 (프로젝트 구조 및 기능 설명용)
- 이후 확장 프로젝트(이상거래 탐지 등)의 요구사항 작성 템플릿으로 활용

### 1.2 범위 (Scope)

본 시스템은 다음과 같은 기능을 제공한다:

- 사용자별 시청/평점 데이터를 기반으로 한 SQL 기반 추천 알고리즘
- 인기 기반 / 장르 기반 / 유사도 기반 추천 제공
- 선택적으로 단순 ML 모델을 활용한 추천 결과 생성 및 비교
- 추천 결과 및 간단 지표를 확인할 수 있는 CLI 인터페이스 (Phase 1)
- 웹 UI (Streamlit) 제공 (Phase 2)

시스템은 개인 포트폴리오 및 학습 목적으로 사용되며, 실제 상용 Netflix 서비스의 모든 기능 구현은 범위에 포함되지 않는다.

### 1.3 정의, 약어 및 용어 (Definitions, Acronyms, Abbreviations)

- **추천 시스템(Recommendation System)**: 사용자에게 맞는 아이템(영화 등)을 자동으로 제안하는 시스템
- **사용자(User)**: 콘텐츠를 시청하거나 평점을 남긴 주체
- **아이템(Item)**: 영화 또는 TV 프로그램
- **평점(Rating)**: 사용자가 아이템에 부여한 점수 (MovieLens 1M 기준: 0.5 ~ 5.0, 0.5 단위)
- **협업 필터링(Collaborative Filtering)**: 사용자-아이템 상호작용(평점)을 기반으로 추천하는 방식
- **콘텐츠 기반 추천(Content-based)**: 아이템의 장르, 키워드 등 메타데이터를 활용한 추천 방식
- **Top-N 추천**: 사용자가 선호할 가능성이 높은 상위 N개의 아이템 리스트
- **Cold Start**: 평점 기록이 없는 신규 사용자 또는 평가 기록이 없는 신규 영화
- **Item-based CF**: 아이템 간 유사도를 기반으로 추천하는 협업 필터링 방식

### 1.4 참고 문서 (References)

- 공개 영화 평점 데이터셋: MovieLens 1M Dataset (https://grouplens.org/datasets/movielens/1m/)
- 내부 프로젝트 문서:
  - PLAN.md: 프로젝트 계획서 및 일정
  - ERD.md (작성 예정): 데이터베이스 스키마 설계
  - README.md (작성 예정): 전체 프로젝트 개요 및 실행 방법

---

## 2. 전반적 설명 (Overall Description)

### 2.1 제품 관점 (Product Perspective)

본 시스템은 단일 사용자 로컬 환경 또는 간단한 웹 애플리케이션 형태로 동작한다.

구성 요소 (초기 버전 기준):

1. **데이터베이스 계층**
   - RDBMS: PostgreSQL
   - 테이블: users, movies, ratings, genres, movie_genres 등

2. **추천 엔진 계층**
   - SQL 기반 추천 로직 (CTE, 윈도우 함수 활용)
   - Python + ML 모델 (옵션, Phase 2)

3. **프레젠테이션 계층**
   - Phase 1: CLI (Python argparse)
   - Phase 2: Streamlit 기반 웹 UI

### 2.2 사용자 특성 (User Characteristics)

- 데이터 분석 및 SQL에 관심 있는 개발자/분석가 (본인)
- 기본적인 Python, SQL 사용 가능자
- 일반 최종 사용자용 서비스가 아니라 포트폴리오/시연용임

### 2.3 제약사항 (Constraints)

- 데이터는 공개된 예시 데이터셋만 사용 (개인정보/실제 Netflix 내부 데이터 사용 금지)
- 리소스 제약: 로컬 개발 환경(노트북/PC)에서 무리 없이 돌아갈 정도의 데이터 크기 사용
- MovieLens 1M 데이터셋 기준: 약 100만 건의 ratings, 약 6,000명의 사용자, 약 4,000개의 영화
- 서비스 가용성, 트래픽 처리 등 대규모 운영 요구사항은 범위에서 제외

### 2.4 가정 및 의존성 (Assumptions and Dependencies)

- 데이터셋은 CSV 형태로 제공되며, 사전에 DB에 로드할 수 있다고 가정
- Python 3.x, PostgreSQL, 필수 라이브러리(pandas, psycopg2, SQLAlchemy 등)가 설치되어 있다고 가정
- 인터넷 연결은 초기 데이터 다운로드 시에만 필요하며, 이후 로컬 환경에서 실행 가능

---

## 3. 시스템 기능 (System Features)

### 3.1 데이터 로딩 및 전처리 기능

#### 3.1.1 설명

외부 CSV 파일로 제공되는 영화, 사용자, 평점 정보를 RDBMS에 로딩하고, 추천 알고리즘에 사용 가능한 형태로 정규화/전처리한다.

#### 3.1.2 기능 요구사항

**FR-1**: 시스템은 movies, ratings, users 관련 CSV 파일을 PostgreSQL DB에 적재할 수 있어야 한다.

**FR-2**: 시스템은 movies와 genres를 분리하여 movie_genres 테이블로 정규화할 수 있어야 한다.

**FR-3**: 시스템은 평점 데이터에서 이상값을 제거해야 한다.
  - 유효한 평점 범위: 0.5 이상 5.0 이하 (0.5 단위)
  - 이 범위를 벗어나는 값 또는 null 값은 이상값으로 간주하여 분석 및 추천 로직에서 제외

**FR-4**: 데이터 로딩 스크립트는 재실행 시 중복 삽입을 방지해야 한다.
  - 기본 정책: TRUNCATE 후 전체 재삽입 방식
  - 향후 UPSERT 방식으로 확장 가능

**FR-5**: 시스템은 movies 테이블의 title에서 개봉 연도를 파싱하여 release_year 컬럼으로 저장해야 한다.
  - 예: "Toy Story (1995)" → title="Toy Story", release_year=1995

**FR-6**: users 테이블의 demographic 정보(성별, 나이, 직업, 우편번호)는 DB에 로드하되, Phase 1 추천 알고리즘에는 사용하지 않는다.
  - EDA 및 분석 용도로만 활용
  - Phase 2에서 demographic 기반 추천으로 확장 가능

**FR-7**: ratings 테이블의 timestamp는 반드시 저장하며, Train/Test 시간 기반 분리에 사용한다.
  - Phase 1 추천 로직에서 recency 가중치는 적용하지 않음
  - Phase 2에서 최근 시청 가중치 기능 확장 가능

### 3.2 인기 기반 추천 기능 (Global Popularity Recommendation)

#### 3.2.1 설명

전체 사용자 데이터를 기반으로, 많이 시청되고 평점이 높은 영화를 전 사용자에게 공통으로 추천하는 기능.

#### 3.2.2 기능 요구사항

**FR-8**: 시스템은 전체 ratings 데이터를 집계하여 영화별 평균 평점, 평점 수를 계산해야 한다.

**FR-9**: 시스템은 최소 평점 수 기준(예: 30회 이상 평가된 영화) 이상인 영화만 추천 후보로 포함해야 한다.

**FR-10**: 사용자가 지정한 상위 N개 영화(Top-N)를 반환할 수 있어야 한다.
  - 기본값: N = 10
  - 최대값: N = 50

**FR-11**: SQL만으로 해당 추천 결과를 생성할 수 있어야 한다.

**FR-12**: 사용자가 이미 평점을 남긴 영화는 기본적으로 추천 결과에서 제외한다.

### 3.3 사용자 선호 장르 기반 추천 기능 (Genre-based Personalized Recommendation)

#### 3.3.1 설명

각 사용자가 과거에 높은 평점을 준 영화들의 장르를 분석하여, 해당 장르에 속하면서 아직 시청하지 않은 영화를 추천한다.

#### 3.3.2 기능 요구사항

**FR-13**: 시스템은 특정 사용자 user_id에 대해, 해당 사용자가 높은 평점을 준 영화들의 장르 분포를 계산해야 한다.

**FR-14**: 시스템은 사용자의 선호 장르를 다음과 같이 정의한다:
  - 장르별 점수 = (해당 장르 영화에 남긴 평점 개수) × (그 장르의 평균 평점)
  - 상위 K개 장르를 선호 장르로 선정 (기본값 K = 3)

**FR-15**: 시스템은 선호 장르에 속하면서, 해당 사용자가 아직 평점을 남기지 않은 영화 목록을 반환해야 한다.

**FR-16**: 위 로직은 하나 이상의 SQL 쿼리(CTE 포함)로 구현 가능해야 한다.

**FR-17**: 추천 결과에서 한 장르가 전체 Top-N의 과도한 비율(예: 80% 이상)을 차지하지 않도록 간단한 다양성 규칙을 고려한다. (Phase 2 확장 항목)

### 3.4 유사도 기반 추천 기능 (Item-based Collaborative Filtering)

#### 3.4.1 설명

특정 영화와 유사한 평가 패턴을 보이는 영화를 추천하거나, 사용자가 높게 평가한 영화들을 기준으로 유사한 영화를 자동 추천한다.

#### 3.4.2 기능 요구사항

**FR-18**: 시스템은 두 영화 간의 유사도를 계산하기 위해 피어슨 상관계수(Pearson Correlation)를 사용한다.
  - 공통 평가 사용자 수가 20명 미만인 영화 쌍은 유사도 계산 대상에서 제외

**FR-19**: 시스템은 특정 기준 영화에 대해, 같은 사용자가 함께 본 영화들을 찾는 SQL 쿼리를 제공해야 한다.

**FR-20**: 시스템은 movie_id를 입력으로 받아, 유사도가 높은 상위 N개 영화를 반환해야 한다.

**FR-21**: 시스템은 특정 user_id를 입력으로 받아, 해당 사용자가 높게 평가한 영화들(예: rating >= 4.0)을 기준으로 유사한 영화를 자동 추천해야 한다. (메인 시나리오)

**FR-22**: 계산 로직은 되도록 SQL 위주로 구현하되, 필요 시 Python 후처리를 허용한다. (예: 유사도 스코어 계산)

**FR-23**: CLI 및 UI에서 다음 두 가지 기능을 제공한다:
  - 사용자 기반 자동 추천: recommend_similar_for_user(user_id)
  - 특정 영화 기반 추천: recommend_similar_for_movie(movie_id)

### 3.5 ML 기반 추천 기능 (Optional)

#### 3.5.1 설명

SQL 기반 추천 기능 외에, 간단한 행렬 분해(Matrix Factorization, 예: SVD) 또는 협업 필터링 라이브러리를 적용해, ML 기반 추천 결과를 생성하고 SQL 방식과 비교한다.

#### 3.5.2 기능 요구사항

**FR-24**: 시스템은 평점 행렬을 모델 학습에 사용할 수 있는 형태로 변환해야 한다.

**FR-25**: 시스템은 기본 모델 1개 이상(예: Logistic Matrix Factorization, SVD 등)을 학습하여 예측 평점을 생성할 수 있어야 한다.

**FR-26**: 시스템은 ML 추천 결과와 SQL 추천 결과를 비교할 수 있는 최소한의 지표를 제공해야 한다.
  - RMSE (예측 평점 정확도)
  - Hit Rate@K, Precision@K, Recall@K (랭킹 평가)
  - nDCG@K (선택적)
  - 기본 K = 10

**FR-27**: ML 로직은 프로젝트 Phase 1 필수는 아니며, Phase 2 기능으로 분리될 수 있다.

### 3.6 추천 알고리즘 통합 및 결합 (Hybrid Recommendation)

#### 3.6.1 설명

Phase 1에서는 3가지 추천 방식(인기 기반, 장르 기반, 유사도 기반)을 별도로 제공하며, Phase 2에서 이들을 가중치 기반으로 결합한 하이브리드 추천을 제공한다.

#### 3.6.2 기능 요구사항

**FR-28**: Phase 1에서는 알고리즘별 추천 결과를 별도 섹션으로 분리하여 제공한다.
  - [인기 기반 추천]
  - [내 선호 장르 기반 추천]
  - [내가 좋아한 영화와 비슷한 추천]

**FR-29**: Phase 2에서 가중치 기반 하이브리드 추천 방식을 도입하는 것을 확장 목표로 한다.
  - 각 알고리즘에서 Top-30 정도 추출
  - 점수 normalize 후 가중치 적용 (예: 장르 0.6, 유사도 0.3, 인기 0.1)
  - 또는 각 알고리즘에서 Top-3~5씩 가져와 섞는 방식

### 3.7 추천 결과 조회 및 UI 기능

#### 3.7.1 설명

사용자가 간단한 인터페이스에서 ID를 입력하면, 추천 영화 리스트를 확인할 수 있는 화면/페이지를 제공한다.

#### 3.7.2 기능 요구사항

**FR-30**: 시스템은 특정 사용자 ID를 입력받아, 다음 추천 결과를 화면에 표시해야 한다:
  - 인기 기반 추천
  - 선호 장르 기반 추천
  - 유사도 기반 추천

**FR-31**: 추천 결과에는 최소한 영화 제목, 개봉 연도, 장르를 포함해야 한다.

**FR-32**: Phase 1에서는 CLI 형태로 구현한다.
  - 예: python main.py --user_id 10 --algo genre --top_n 10

**FR-33**: Phase 2에서는 Streamlit 기반 웹 UI를 제공한다.
  - user_id 선택 (드롭다운 또는 입력)
  - 알고리즘 선택 (라디오 버튼: 인기/장르/유사도/하이브리드)
  - Top-N 슬라이더 (1~50)
  - 결과 테이블 (제목, 연도, 장르, 예측 점수)

**FR-34**: Phase 2 확장으로 TMDB API 연동 시 영화 포스터 및 줄거리를 추가할 수 있다. (선택적)

### 3.8 Cold Start 처리

#### 3.8.1 설명

평점 기록이 없는 신규 사용자에게 추천을 제공하는 정책.

#### 3.8.2 기능 요구사항

**FR-35**: Cold Start 사용자(평점 기록이 없는 사용자)에 대해서는, 개별화 추천 대신 인기 기반 추천(전체 사용자 기준 Top-N)을 기본으로 제공한다.

**FR-36**: Phase 2 확장으로, UI에서 "좋아하는 장르 선택" 인터페이스를 제공하여 장르 + 인기 조합 추천을 제공할 수 있다. (선택적)

### 3.9 이미 본 영화 필터링

#### 3.9.1 설명

사용자가 이미 평점을 남긴 영화를 추천 결과에서 제외하는 정책.

#### 3.9.2 기능 요구사항

**FR-37**: 사용자가 이미 시청(평점)한 영화는, 모든 추천 방식에서 기본적으로 추천 결과에서 제외한다.
  - 평점 값과 무관하게, 한 번이라도 평점을 남긴 영화는 "이미 본 영화"로 간주

**FR-38**: Phase 2 확장으로, 사용자가 4.0 이상 준 영화를 별도 섹션("다시 보기 추천")으로 제공할 수 있다. (선택적)

---

## 4. 비기능 요구사항 (Non-functional Requirements)

### 4.1 성능 요구사항

**NFR-1**: Top-N 추천 쿼리는 단일 사용자 기준 3초 이내(최대 5초)에 결과를 반환하는 것을 목표로 한다.

**NFR-2**: 데이터셋 규모는 MovieLens 1M 기준으로 제한한다.
  - 약 100만 건의 ratings
  - 약 6,000명의 사용자
  - 약 4,000개의 영화

**NFR-3**: 개발 단계에서 쿼리 실행 시간을 로깅하고, 필요 시 EXPLAIN ANALYZE로 쿼리 최적화를 수행한다.

**NFR-4**: 쿼리 실행 시간이 5초를 초과하는 경우, 콘솔/로그에 경고 메시지를 남기되 시스템은 정상 동작한다.

### 4.2 사용성 (Usability)

**NFR-5**: 추천 결과 화면은 최소한의 필드(제목, 장르, 개봉 연도)를 명확하게 표시해야 한다.

**NFR-6**: 프로젝트 문서(README, SRS, PLAN)는 누구나 읽고 이해할 수 있도록 구조화해야 한다.

**NFR-7**: CLI 명령어는 직관적이고 일관성 있게 설계해야 한다.

### 4.3 유지보수성 (Maintainability)

**NFR-8**: SQL 쿼리는 재사용 가능한 뷰 또는 스크립트 형태로 관리한다.

**NFR-9**: 추천 알고리즘별로 모듈을 나누어, 새로운 알고리즘 추가 시 기존 코드 변경을 최소화한다.

**NFR-10**: 코드는 함수 단위로 분리하고, 각 함수는 단일 책임 원칙을 따른다.

### 4.4 이식성 (Portability)

**NFR-11**: DB는 PostgreSQL을 기본으로 하되, SQLAlchemy ORM을 사용하여 다른 RDBMS로의 마이그레이션 가능성을 고려한다.

**NFR-12**: 개발 환경에서는 SQLite로 테스트 가능하도록 DB 연결 부분을 추상화한다. (선택적)

### 4.5 확장성 (Scalability)

**NFR-13**: 본 시스템은 단일 사용자 혹은 소수 사용자(1~5명)가 사용하는 데모/포트폴리오 용도로 설계된다.

**NFR-14**: 동시 다중 사용자 접속, 대규모 트래픽 처리는 범위에서 제외한다.

### 4.6 보안 (Security)

**SEC-1**: 사용자 입력값을 이용한 SQL 쿼리는 반드시 파라미터 바인딩(Prepared Statement 등)을 사용하여 SQL Injection을 방지한다.

---

## 5. 데이터 요구사항 (Data Requirements)

### 5.1 데이터 소스

**DR-1**: MovieLens 1M Dataset (https://grouplens.org/datasets/movielens/1m/)
  - users.dat: UserID::Gender::Age::Occupation::Zip-code
  - movies.dat: MovieID::Title::Genres
  - ratings.dat: UserID::MovieID::Rating::Timestamp

### 5.2 데이터베이스 스키마

**DR-2**: users 테이블
  - user_id (PK)
  - gender
  - age
  - occupation
  - zip_code

**DR-3**: movies 테이블
  - movie_id (PK)
  - title
  - release_year
  - (description: null 또는 미사용, Phase 2 확장 항목)

**DR-4**: genres 테이블
  - genre_id (PK)
  - genre_name

**DR-5**: movie_genres 테이블 (다대다 관계)
  - movie_id (FK)
  - genre_id (FK)
  - PK: (movie_id, genre_id)

**DR-6**: ratings 테이블
  - rating_id (PK, auto-increment)
  - user_id (FK)
  - movie_id (FK)
  - rating (DECIMAL, 0.5~5.0)
  - timestamp (BIGINT 또는 TIMESTAMP)

**DR-7**: 실제 컬럼명/구조는 ERD.md 또는 schema.sql에서 상세 정의 예정

### 5.3 데이터 갱신 정책

**DR-8**: 데이터 로딩 스크립트는 실행 시 대상 테이블을 TRUNCATE한 이후 전체 데이터를 재삽입하는 방식을 기본 정책으로 한다.

**DR-9**: 향후 UPSERT 방식으로 확장 가능하며, 이는 Phase 2 확장 항목으로 고려한다.

### 5.4 Train/Test 데이터 분리

**DR-10**: 평가를 위해 ratings 데이터를 Train/Test로 분리한다.
  - 방식: 시간 기반 분리 (사용자별 timestamp 기준 정렬 후, 각 사용자의 최근 약 20%를 test set으로 사용)
  - 목적: 과거 행동으로 미래 시청을 예측하는 현실적인 추천 시스템 평가

**DR-11**: SQL 기반 추천 및 ML 기반 추천 모두 동일한 train/test split을 사용하여 공정하게 비교한다.

---

## 6. 평가 지표 (Evaluation Metrics)

### 6.1 오프라인 평가 지표

**EM-1**: 추천 모델 평가는 다음 지표를 사용한다:
  - RMSE: 예측 평점 정확도 (회귀형 평가)
  - Hit Rate@K: Top-K 추천에 실제 시청한 영화가 포함된 비율
  - Precision@K: Top-K 추천 중 실제 시청한 영화의 비율
  - Recall@K: 실제 시청한 영화 중 Top-K에 포함된 비율
  - nDCG@K: 순위를 고려한 추천 품질 (선택적)
  - 기본 K = 10

**EM-2**: SQL 기반 추천 방식과 ML 기반 추천 방식을 동일한 평가 데이터셋에서 동일 지표로 비교한다.

### 6.2 정성적 평가

**EM-3**: 추천 결과의 다양성(Diversity), 참신함(Novelty), 설명 가능성(Explainability)을 정성적으로 평가한다. (문서화 목적)

---

## 7. 에러 처리 (Error Handling)

### 7.1 사용자 입력 오류

**EH-1**: 존재하지 않는 user_id 또는 movie_id가 입력된 경우:
  - 에러 메시지를 표시하고 추천을 수행하지 않거나
  - 인기 기반 추천 결과를 대체로 제공

**EH-2**: 잘못된 형식의 입력(예: 문자열 대신 숫자 입력)이 들어온 경우:
  - 명확한 에러 메시지 출력 및 사용 예시 제공

### 7.2 시스템 오류

**EH-3**: DB 연결 실패 및 쿼리 타임아웃 등의 오류:
  - 로그로 기록
  - 사용자에게는 일반화된 오류 메시지 표시 ("일시적인 오류가 발생했습니다. 다시 시도해주세요.")

**EH-4**: 치명적 오류 발생 시:
  - 상세 로그 출력
  - 애플리케이션 종료 또는 재시작 안내

---

## 8. 프로젝트 단계별 범위 (Phase-based Scope)

### 8.1 Phase 1 (MVP: Minimum Viable Product)

- 데이터 로딩 및 전처리
- 3가지 추천 알고리즘 구현 (SQL 기반)
  - 인기 기반 추천
  - 장르 기반 추천
  - 유사도 기반 추천 (Item-based CF)
- CLI 인터페이스
- Train/Test 분리 및 기본 평가 지표 (RMSE, Hit Rate@10, Precision@10, Recall@10)
- 프로젝트 문서화 (README, SRS, PLAN, ERD)

### 8.2 Phase 2 (확장 및 고도화)

- ML 기반 추천 (SVD, Matrix Factorization 등)
- 하이브리드 추천 (가중치 기반 결합)
- Streamlit 웹 UI
- TMDB API 연동 (포스터, 줄거리)
- Demographic 기반 추천
- Recency 가중치 적용
- 추천 다양성(Diversity) 규칙
- "다시 보기 추천" 기능
- 추가 평가 지표 (nDCG, Coverage 등)

---

## 9. 버전 관리 (Version History)

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 1.0 | 2025-12-04 | 개발자 | 초안 작성 |

---

## 부록 A: 용어 정리

- **Pearson Correlation**: 두 변수 간의 선형 상관관계를 측정하는 통계 지표 (-1 ~ 1)
- **CTE (Common Table Expression)**: SQL에서 WITH 절을 사용한 임시 결과 집합
- **윈도우 함수(Window Function)**: ROW_NUMBER(), RANK(), DENSE_RANK() 등 그룹 내 순위/집계를 수행하는 SQL 함수
- **RMSE (Root Mean Square Error)**: 예측값과 실제값의 차이를 제곱한 평균의 제곱근
- **Hit Rate@K**: Top-K 추천에 실제 시청한 아이템이 하나라도 포함된 비율
- **Precision@K**: Top-K 추천 중 실제 관련 있는 아이템의 비율
- **Recall@K**: 실제 관련 있는 아이템 중 Top-K에 포함된 비율
- **nDCG@K (normalized Discounted Cumulative Gain)**: 순위를 고려한 추천 품질 평가 지표

---

문서 끝.
